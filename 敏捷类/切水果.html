<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åˆ‡æ°´æœ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            padding: 15px;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        h1 { color: #fff; font-size: 2rem; margin-bottom: 10px; }

        .info-bar {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
        }

        .info-item {
            background: rgba(255,255,255,0.15);
            padding: 8px 18px;
            border-radius: 20px;
            color: #fff;
            font-size: 1.1rem;
        }

        .game-container {
            width: 100%;
            max-width: 400px;
            height: 500px;
            background: linear-gradient(to bottom, #1e3c72, #2a5298);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 15px 50px rgba(0,0,0,0.5);
            cursor: crosshair;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .start-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            background: rgba(0,0,0,0.7);
            padding: 25px 50px;
            border-radius: 15px;
            cursor: pointer;
            z-index: 10;
            border: 3px solid #f1c40f;
        }

        .start-hint:active {
            transform: translate(-50%, -50%) scale(0.95);
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .game-over-content {
            background: linear-gradient(135deg, #fff, #f0f0f0);
            padding: 40px 50px;
            border-radius: 20px;
            text-align: center;
            animation: pop 0.4s ease;
        }

        @keyframes pop {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .game-over-content h2 {
            color: #e74c3c;
            font-size: 2rem;
            margin-bottom: 15px;
        }

        .game-over-content p {
            font-size: 1.3rem;
            color: #333;
            margin-bottom: 25px;
        }

        .game-over-content button {
            padding: 12px 30px;
            font-size: 1.1rem;
            background: #27ae60;
            color: #fff;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
        }

        .game-over-content button:hover {
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <h1>ğŸ”ª åˆ‡æ°´æœ</h1>

    <div class="info-bar">
        <div class="info-item">å¾—åˆ†: <span id="score">0</span></div>
        <div class="info-item">ç”Ÿå‘½: <span id="lives">â¤ï¸â¤ï¸â¤ï¸</span></div>
    </div>

    <div class="game-container" id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="start-hint" id="startHint" onclick="startGame()">ç‚¹å‡»å¼€å§‹æ¸¸æˆ</div>
    </div>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <h2>ğŸ’¥ æ¸¸æˆç»“æŸ!</h2>
            <p>å¾—åˆ†: <span id="finalScore">0</span></p>
            <button onclick="restartGame()">å†æ¥ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('gameContainer');

        // è®¾ç½®canvaså°ºå¯¸
        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const fruits = ['ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸ‰', 'ğŸ‡', 'ğŸ“', 'ğŸ‘', 'ğŸ¥'];
        const bomb = 'ğŸ’£';

        let score = 0;
        let lives = 3;
        let gameRunning = false;
        let spawnTimer = null;
        let items = [];
        let combo = 0;
        let lastSliceTime = 0;

        // åˆ€å…‰è½¨è¿¹
        let trailPoints = [];
        const maxTrailLength = 15;

        // é¼ æ ‡/è§¦æ‘¸ä½ç½®
        let lastX = 0;
        let lastY = 0;
        let isTouching = false;

        // ç»˜åˆ¶åˆ€å…‰è½¨è¿¹
        function drawTrail() {
            if (trailPoints.length < 2) return;

            ctx.beginPath();
            ctx.moveTo(trailPoints[0].x, trailPoints[0].y);

            for (let i = 1; i < trailPoints.length; i++) {
                ctx.lineTo(trailPoints[i].x, trailPoints[i].y);
            }

            // æ¸å˜æ•ˆæœ
            const gradient = ctx.createLinearGradient(
                trailPoints[0].x, trailPoints[0].y,
                trailPoints[trailPoints.length-1].x, trailPoints[trailPoints.length-1].y
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();

            // ç™½è‰²æ ¸å¿ƒ
            ctx.beginPath();
            ctx.moveTo(trailPoints[0].x, trailPoints[0].y);
            for (let i = 1; i < trailPoints.length; i++) {
                ctx.lineTo(trailPoints[i].x, trailPoints[i].y);
            }
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function addTrailPoint(x, y) {
            trailPoints.push({x, y, time: Date.now()});
            // ç§»é™¤å¤ªæ—§çš„ç‚¹
            while (trailPoints.length > maxTrailLength) {
                trailPoints.shift();
            }
        }

        // ç¢°æ’æ£€æµ‹ï¼šçº¿æ®µä¸åœ†
        function lineCircleIntersect(x1, y1, x2, y2, cx, cy, r) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const fx = x1 - cx;
            const fy = y1 - cy;

            const a = dx * dx + dy * dy;
            const b = 2 * (fx * dx + fy * dy);
            const c = fx * fx + fy * fy - r * r;

            let discriminant = b * b - 4 * a * c;

            if (discriminant < 0) return false;

            discriminant = Math.sqrt(discriminant);
            const t1 = (-b - discriminant) / (2 * a);
            const t2 = (-b + discriminant) / (2 * a);

            return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
        }

        function checkSlice(x, y) {
            if (trailPoints.length < 2) return;

            const lastPoint = trailPoints[trailPoints.length - 2];
            const radius = 30;

            items.forEach((item, index) => {
                if (item.sliced) return;

                const intersects = lineCircleIntersect(
                    lastPoint.x, lastPoint.y,
                    x, y,
                    item.x, item.y, radius
                );

                if (intersects) {
                    sliceItem(item);
                }
            });
        }

        function sliceItem(item) {
            const isBomb = item.isBomb;

            if (isBomb) {
                item.sliced = true;
                lives--;

                let hearts = '';
                for (let i = 0; i < lives; i++) hearts += 'â¤ï¸';
                for (let i = lives; i < 3; i++) hearts += 'ğŸ–¤';
                document.getElementById('lives').textContent = hearts;

                // çˆ†ç‚¸æ•ˆæœ
                showExplosion(item.x, item.y);

                if (lives <= 0) {
                    gameOver();
                }
            } else {
                item.sliced = true;

                // è¿å‡»æ£€æµ‹
                const now = Date.now();
                if (now - lastSliceTime < 500) {
                    combo++;
                } else {
                    combo = 1;
                }
                lastSliceTime = now;

                const points = 10 * combo;
                score += points;
                document.getElementById('score').textContent = score;

                // æ˜¾ç¤ºåˆ†æ•°
                showScore(item.x, item.y, points, combo);

                // æ˜¾ç¤ºåˆ‡å‰²æ•ˆæœ
                showSliceEffect(item);
            }
        }

        function showScore(x, y, points, combo) {
            const container = document.getElementById('gameContainer');
            const elem = document.createElement('div');
            elem.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y}px;
                color: #f1c40f;
                font-size: ${combo >= 2 ? '2rem' : '1.5rem'};
                font-weight: bold;
                pointer-events: none;
                animation: scoreFloat 0.8s ease forwards;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
                z-index: 5;
            `;
            elem.textContent = combo >= 2 ? `${combo}è¿å‡»! +${points}` : `+${points}`;
            container.appendChild(elem);

            setTimeout(() => elem.remove(), 800);
        }

        function showSliceEffect(item) {
            // åˆ›å»ºä¸¤åŠæ°´æœ
            const leftHalf = document.createElement('div');
            const rightHalf = document.createElement('div');

            leftHalf.style.cssText = `
                position: absolute;
                left: ${item.x - 20}px;
                top: ${item.y}px;
                font-size: 2.5rem;
                pointer-events: none;
                animation: sliceLeft 0.5s ease forwards;
                z-index: 4;
            `;
            rightHalf.style.cssText = `
                position: absolute;
                left: ${item.x + 20}px;
                top: ${item.y}px;
                font-size: 2.5rem;
                pointer-events: none;
                animation: sliceRight 0.5s ease forwards;
                z-index: 4;
            `;

            // ç®€å•çš„åˆ‡å‰²æ•ˆæœ
            leftHalf.textContent = item.emoji + 'ğŸ‰'[0];
            rightHalf.textContent = item.emoji;

            container.appendChild(leftHalf);
            container.appendChild(rightHalf);

            setTimeout(() => {
                leftHalf.remove();
                rightHalf.remove();
            }, 500);
        }

        function showExplosion(x, y) {
            const elem = document.createElement('div');
            elem.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y}px;
                font-size: 4rem;
                pointer-events: none;
                animation: explode 0.5s ease forwards;
                z-index: 6;
            `;
            elem.textContent = 'ğŸ’¥';
            container.appendChild(elem);
            setTimeout(() => elem.remove(), 500);
        }

        // æ·»åŠ åŠ¨ç”»æ ·å¼
        const style = document.createElement('style');
        style.textContent = `
            @keyframes scoreFloat {
                0% { transform: translateY(0) scale(1); opacity: 1; }
                100% { transform: translateY(-60px) scale(1.2); opacity: 0; }
            }
            @keyframes sliceLeft {
                0% { transform: translateX(0) rotate(0deg); opacity: 1; }
                100% { transform: translateX(-40px) rotate(-20deg); opacity: 0; }
            }
            @keyframes sliceRight {
                0% { transform: translateX(0) rotate(0deg); opacity: 1; }
                100% { transform: translateX(40px) rotate(20deg); opacity: 0; }
            }
            @keyframes explode {
                0% { transform: scale(0.5); opacity: 1; }
                50% { transform: scale(1.5); opacity: 1; }
                100% { transform: scale(2); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // è¾“å…¥äº‹ä»¶å¤„ç†
        function handleStart(x, y) {
            isTouching = true;
            lastX = x;
            lastY = y;
            trailPoints = [];
            addTrailPoint(x, y);
        }

        function handleMove(x, y) {
            if (!isTouching) return;

            addTrailPoint(x, y);
            checkSlice(x, y);
            lastX = x;
            lastY = y;
        }

        function handleEnd() {
            isTouching = false;
            // ä¿ç•™è½¨è¿¹ä¸€å°æ®µæ—¶é—´åæ¸…é™¤
            setTimeout(() => {
                if (!isTouching) trailPoints = [];
            }, 100);
        }

        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            handleStart(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            handleMove(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);

        // è§¦æ‘¸äº‹ä»¶
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            handleStart(touch.clientX - rect.left, touch.clientY - rect.top);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            handleMove(touch.clientX - rect.left, touch.clientY - rect.top);
        }, { passive: false });

        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);

        function startGame() {
            if (gameRunning) return;

            score = 0;
            lives = 3;
            items = [];
            combo = 0;
            trailPoints = [];
            gameRunning = true;

            document.getElementById('score').textContent = '0';
            document.getElementById('lives').textContent = 'â¤ï¸â¤ï¸â¤ï¸';
            document.getElementById('startHint').style.display = 'none';

            spawnTimer = setInterval(spawnItem, 700);
            gameLoop();
        }

        function spawnItem() {
            if (!gameRunning) return;

            const isBomb = Math.random() < 0.12;
            const emoji = isBomb ? bomb : fruits[Math.floor(Math.random() * fruits.length)];

            const item = {
                x: 50 + Math.random() * (canvas.width - 100),
                y: canvas.height + 30,
                vx: (Math.random() - 0.5) * 3,
                vy: -(9 + Math.random() * 4),
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.2,
                emoji: emoji,
                isBomb: isBomb,
                sliced: false
            };

            items.push(item);
        }

        function gameLoop() {
            if (!gameRunning) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶æ°´æœ
            items.forEach((item, index) => {
                // ç‰©ç†æ›´æ–°
                item.vy += 0.2;
                item.x += item.vx;
                item.y += item.vy;
                item.rotation += item.rotationSpeed;

                // ç»˜åˆ¶
                ctx.save();
                ctx.translate(item.x, item.y);
                ctx.rotate(item.rotation);
                ctx.font = '2.5rem Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (item.sliced) {
                    ctx.globalAlpha = 0;
                }

                ctx.fillText(item.emoji, 0, 0);
                ctx.restore();

                // ç§»é™¤è¶…å‡ºå±å¹•çš„
                if (item.y > canvas.height + 50) {
                    if (!item.sliced && !item.isBomb) {
                        combo = 0;
                    }
                    items.splice(index, 1);
                }
            });

            // ç»˜åˆ¶åˆ€å…‰è½¨è¿¹
            drawTrail();

            // æ¸…ç†æ—§è½¨è¿¹ç‚¹
            const now = Date.now();
            trailPoints = trailPoints.filter(p => now - p.time < 100);

            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameRunning = false;
            clearInterval(spawnTimer);
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverOverlay').style.display = 'flex';
        }

        function restartGame() {
            document.getElementById('gameOverOverlay').style.display = 'none';
            items = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            startGame();
        }
    </script>
</body>
</html>
