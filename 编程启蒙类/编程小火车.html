<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¼–ç¨‹å°ç«è½¦</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            padding: 15px;
            user-select: none;
        }

        h1 {
            color: #fff;
            font-size: 2rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .info-bar {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .info-item {
            background: rgba(255,255,255,0.25);
            padding: 8px 20px;
            border-radius: 20px;
            color: #fff;
            font-size: 1.1rem;
            backdrop-filter: blur(5px);
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #gameCanvas {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            cursor: pointer;
            max-width: 100%;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 28px;
            font-size: 1.1rem;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-run {
            background: #27ae60;
            color: #fff;
        }

        .btn-clear {
            background: #e74c3c;
            color: #fff;
        }

        .btn-reset {
            background: #f39c12;
            color: #fff;
        }

        .btn-next {
            background: #9b59b6;
            color: #fff;
        }

        .instructions {
            color: rgba(255,255,255,0.9);
            font-size: 0.95rem;
            text-align: center;
            max-width: 400px;
            line-height: 1.5;
        }

        .path-preview {
            color: #f1c40f;
            font-weight: bold;
        }

        /* æ¸¸æˆç»“æŸå¼¹çª— */
        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .game-over-content {
            background: linear-gradient(135deg, #fff, #f0f0f0);
            padding: 40px 50px;
            border-radius: 20px;
            text-align: center;
            animation: pop 0.4s ease;
        }

        @keyframes pop {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .game-over-content h2 {
            color: #27ae60;
            font-size: 2rem;
            margin-bottom: 15px;
        }

        .game-over-content .fail-text {
            color: #e74c3c;
        }

        .game-over-content p {
            font-size: 1.2rem;
            color: #333;
            margin-bottom: 25px;
        }

        .game-over-content .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-over-content button {
            padding: 12px 30px;
            font-size: 1rem;
        }

        /* æˆåŠŸæ˜Ÿæ˜ŸåŠ¨ç”» */
        .stars {
            font-size: 2.5rem;
            margin-bottom: 15px;
        }

        .star {
            display: inline-block;
            animation: starPop 0.5s ease backwards;
        }

        .star:nth-child(2) { animation-delay: 0.2s; }
        .star:nth-child(3) { animation-delay: 0.4s; }

        @keyframes starPop {
            0% { transform: scale(0) rotate(-180deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        @media (max-width: 500px) {
            h1 { font-size: 1.6rem; }
            .info-item { font-size: 0.95rem; padding: 6px 15px; }
            button { padding: 10px 20px; font-size: 1rem; }
        }
    </style>
</head>
<body>
    <h1>ğŸš‚ ç¼–ç¨‹å°ç«è½¦</h1>

    <div class="info-bar">
        <div class="info-item">å…³å¡: <span id="level">1</span></div>
        <div class="info-item">â­ æ˜Ÿæ˜Ÿ: <span id="stars">0</span>/3</div>
    </div>

    <div class="game-wrapper">
        <canvas id="gameCanvas" width="360" height="360"></canvas>

        <div class="controls">
            <button class="btn-run" onclick="runTrain()">ğŸš‚ å‡ºå‘!</button>
            <button class="btn-clear" onclick="clearPath()">ğŸ—‘ï¸ æ¸…ç©º</button>
            <button class="btn-reset" onclick="resetLevel()">ğŸ”„ é‡ç½®</button>
        </div>

        <p class="instructions">
            ç‚¹å‡»æ ¼å­ç»˜åˆ¶è·¯çº¿ï¼Œè®©ç«è½¦ä» <span style="color:#2ecc71">ğŸ </span> åˆ°è¾¾ <span style="color:#e74c3c">ğŸ</span><br>
            è·¯å¾„é¢„è§ˆ: <span class="path-preview" id="pathLen">0</span> æ ¼
        </p>
    </div>

    <!-- æ¸¸æˆç»“æŸå¼¹çª— -->
    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content" id="gameOverContent">
            <!-- å†…å®¹ç”±JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // æ¸¸æˆé…ç½®
        const GRID_SIZE = 8;
        const TILE_SIZE = canvas.width / GRID_SIZE;

        // æ ¼å­ç±»å‹
        const EMPTY = 0;
        const OBSTACLE = 1;
        const START = 2;
        const END = 3;
        const PATH = 4;
        const COIN = 5;

        // å…³å¡æ•°æ®
        const levels = [
            // Level 1: ç®€å•ç›´çº¿è·¯çº¿
            {
                grid: [
                    [0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0],
                    [2,0,0,0,0,0,0,3],
                    [0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0]
                ],
                coins: []
            },
            // Level 2: æœ‰ä¸€ä¸ªéšœç¢
            {
                grid: [
                    [0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0],
                    [2,0,0,1,0,0,0,0],
                    [0,0,0,1,0,0,3,0],
                    [0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0]
                ],
                coins: [{x:6,y:1}]
            },
            // Level 3: å¤šä¸ªéšœç¢
            {
                grid: [
                    [0,0,0,0,0,0,0,0],
                    [0,1,0,0,0,1,0,0],
                    [2,1,0,1,0,1,0,0],
                    [0,0,0,1,0,0,0,0],
                    [0,1,0,1,0,1,1,0],
                    [0,1,0,0,0,0,0,0],
                    [0,1,0,1,0,1,0,3],
                    [0,0,0,0,0,0,0,0]
                ],
                coins: [{x:2,y:3}, {x:4,y:5}]
            },
            // Level 4: æ›´å¤æ‚
            {
                grid: [
                    [2,0,0,0,1,0,0,0],
                    [1,1,1,0,1,0,1,0],
                    [0,0,0,0,0,0,1,0],
                    [0,1,1,1,1,0,1,0],
                    [0,0,0,0,1,0,0,0],
                    [0,1,0,0,1,1,1,0],
                    [0,1,0,0,0,0,0,0],
                    [0,0,0,1,1,0,1,3]
                ],
                coins: [{x:0,y:5}, {x:3,y:2}, {x:6,y:4}]
            },
            // Level 5: æŒ‘æˆ˜
            {
                grid: [
                    [0,0,0,1,3,0,0,0],
                    [0,1,0,1,1,1,1,0],
                    [0,1,0,0,0,0,0,0],
                    [0,1,1,1,1,1,0,0],
                    [0,0,0,0,0,1,0,0],
                    [1,1,1,1,0,1,0,1],
                    [2,0,0,0,0,0,0,0],
                    [0,1,1,1,1,1,0,0]
                ],
                coins: [{x:2,y:2}, {x:0,y:4}, {x:4,y:3}]
            }
        ];

        // æ¸¸æˆçŠ¶æ€
        let currentLevel = 0;
        let grid = [];
        let path = [];
        let trainPos = {x: 0, y: 0};
        let startPos = {x: 0, y: 0};
        let endPos = {x: 0, y: 0};
        let coins = [];
        let collectedCoins = 0;
        let isRunning = false;
        let trainAnimation = null;
        let totalStars = 0;

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            loadLevel(currentLevel);
            draw();
        }

        // åŠ è½½å…³å¡
        function loadLevel(levelIndex) {
            const level = levels[levelIndex];
            grid = JSON.parse(JSON.stringify(level.grid));
            coins = level.coins ? [...level.coins] : [];
            collectedCoins = 0;

            // æ‰¾åˆ°èµ·ç‚¹å’Œç»ˆç‚¹
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === START) {
                        startPos = {x, y};
                        trainPos = {x, y};
                    }
                    if (grid[y][x] === END) {
                        endPos = {x, y};
                    }
                }
            }

            path = [{x: startPos.x, y: startPos.y}];
            isRunning = false;

            document.getElementById('level').textContent = levelIndex + 1;
            document.getElementById('stars').textContent = '0';
            document.getElementById('pathLen').textContent = '0';
        }

        // ç»˜åˆ¶æ¸¸æˆ
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;

                    // äº¤æ›¿èƒŒæ™¯è‰²
                    if ((x + y) % 2 === 0) {
                        ctx.fillStyle = '#ecf0f1';
                    } else {
                        ctx.fillStyle = '#dfe6e9';
                    }
                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

                    // ç»˜åˆ¶æ ¼å­å†…å®¹
                    const cell = grid[y][x];
                    ctx.font = `${TILE_SIZE * 0.6}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    if (cell === OBSTACLE) {
                        ctx.fillText('ğŸŒ²', px + TILE_SIZE/2, py + TILE_SIZE/2);
                    } else if (cell === START) {
                        ctx.fillText('ğŸ ', px + TILE_SIZE/2, py + TILE_SIZE/2);
                    } else if (cell === END) {
                        ctx.fillText('ğŸ', px + TILE_SIZE/2, py + TILE_SIZE/2);
                    }
                }
            }

            // ç»˜åˆ¶é‡‘å¸
            coins.forEach(coin => {
                if (!isCoinCollected(coin)) {
                    const px = coin.x * TILE_SIZE + TILE_SIZE/2;
                    const py = coin.y * TILE_SIZE + TILE_SIZE/2;
                    ctx.font = `${TILE_SIZE * 0.5}px Arial`;
                    ctx.fillText('â­', px, py);
                }
            });

            // ç»˜åˆ¶è·¯å¾„
            if (path.length > 1) {
                ctx.strokeStyle = 'rgba(52, 152, 219, 0.6)';
                ctx.lineWidth = TILE_SIZE * 0.4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(path[0].x * TILE_SIZE + TILE_SIZE/2,
                           path[0].y * TILE_SIZE + TILE_SIZE/2);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x * TILE_SIZE + TILE_SIZE/2,
                               path[i].y * TILE_SIZE + TILE_SIZE/2);
                }
                ctx.stroke();
            }

            // ç»˜åˆ¶ç«è½¦
            const trainX = trainPos.x * TILE_SIZE + TILE_SIZE/2;
            const trainY = trainPos.y * TILE_SIZE + TILE_SIZE/2;
            ctx.font = `${TILE_SIZE * 0.7}px Arial`;
            ctx.fillText('ğŸš‚', trainX, trainY);
        }

        // æ£€æŸ¥é‡‘å¸æ˜¯å¦å·²æ”¶é›†
        function isCoinCollected(coin) {
            return collectedCoins > 0 && coins.indexOf(coin) < collectedCoins;
        }

        // ç‚¹å‡»å¤„ç†
        canvas.addEventListener('click', (e) => {
            if (isRunning) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX / TILE_SIZE);
            const y = Math.floor((e.clientY - rect.top) * scaleY / TILE_SIZE);

            if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;

            // ä¸èƒ½ç‚¹å‡»éšœç¢ç‰©å’Œèµ·ç‚¹ç»ˆç‚¹
            if (grid[y][x] === OBSTACLE) return;
            if (x === startPos.x && y === startPos.y) return;
            if (x === endPos.x && y === endPos.y) {
                // ç‚¹å‡»ç»ˆç‚¹ï¼Œå¼€å§‹è¿è¡Œ
                addToPath(x, y);
                runTrain();
                return;
            }

            addToPath(x, y);
            draw();
        });

        // æ·»åŠ åˆ°è·¯å¾„
        function addToPath(x, y) {
            if (path.length === 0) return;

            const last = path[path.length - 1];

            // åªèƒ½æ·»åŠ ç›¸é‚»çš„æ ¼å­
            const dx = Math.abs(x - last.x);
            const dy = Math.abs(y - last.y);
            if (dx + dy !== 1) return;

            // æ£€æŸ¥æ˜¯å¦æ˜¯éšœç¢ç‰©
            if (grid[y][x] === OBSTACLE) return;

            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨äºè·¯å¾„ä¸­ï¼ˆä¸èƒ½å›å¤´ï¼‰
            const exists = path.some(p => p.x === x && p.y === y);
            if (exists) {
                // å¦‚æœç‚¹å‡»çš„æ˜¯è·¯å¾„ä¸­çš„æ ¼å­ï¼Œæˆªæ–­è·¯å¾„
                const index = path.findIndex(p => p.x === x && p.y === y);
                path = path.slice(0, index + 1);
            } else {
                path.push({x, y});
            }

            document.getElementById('pathLen').textContent = path.length - 1;
        }

        // æ¸…ç©ºè·¯å¾„
        function clearPath() {
            if (isRunning) return;
            path = [{x: startPos.x, y: startPos.y}];
            trainPos = {x: startPos.x, y: startPos.y};
            collectedCoins = 0;
            draw();
            document.getElementById('pathLen').textContent = '0';
        }

        // é‡ç½®å…³å¡
        function resetLevel() {
            if (trainAnimation) {
                cancelAnimationFrame(trainAnimation);
                trainAnimation = null;
            }
            loadLevel(currentLevel);
            draw();
        }

        // è¿è¡Œç«è½¦
        function runTrain() {
            if (isRunning || path.length < 2) return;

            // æ£€æŸ¥ç»ˆç‚¹æ˜¯å¦åœ¨è·¯å¾„ä¸­
            const lastPoint = path[path.length - 1];
            if (lastPoint.x !== endPos.x || lastPoint.y !== endPos.y) {
                alert('è¯·è§„åˆ’è·¯çº¿åˆ°è¾¾ç»ˆç‚¹ï¼');
                return;
            }

            // æ£€æŸ¥è·¯å¾„æ˜¯å¦æœ‰æ•ˆï¼ˆä¸èƒ½ç©¿è¿‡éšœç¢ç‰©ï¼‰
            for (let i = 1; i < path.length; i++) {
                const p = path[i];
                if (grid[p.y][p.x] === OBSTACLE) {
                    alert('è·¯å¾„ä¸èƒ½ç»è¿‡éšœç¢ç‰©ï¼');
                    return;
                }
            }

            isRunning = true;
            let pathIndex = 0;

            function animate() {
                if (pathIndex >= path.length - 1) {
                    // åˆ°è¾¾ç»ˆç‚¹
                    checkWin();
                    return;
                }

                pathIndex++;
                trainPos = {x: path[pathIndex].x, y: path[pathIndex].y};

                // æ£€æŸ¥æ”¶é›†é‡‘å¸
                const coinIndex = coins.findIndex(c => c.x === trainPos.x && c.y === trainPos.y);
                if (coinIndex >= 0 && coinIndex === collectedCoins) {
                    collectedCoins++;
                    document.getElementById('stars').textContent = collectedCoins;
                }

                draw();

                setTimeout(() => {
                    trainAnimation = requestAnimationFrame(animate);
                }, 300);
            }

            trainAnimation = requestAnimationFrame(animate);
        }

        // æ£€æŸ¥èƒœåˆ©
        function checkWin() {
            const starCount = collectedCoins;
            totalStars += starCount;

            const overlay = document.getElementById('gameOverOverlay');
            const content = document.getElementById('gameOverContent');

            let starText = '';
            for (let i = 0; i < 3; i++) {
                starText += `<span class="star" style="color:${i < starCount ? '#f1c40f' : '#ccc'}">â­</span>`;
            }

            if (currentLevel < levels.length - 1) {
                content.innerHTML = `
                    <h2>ğŸ‰ è¿‡å…³å•¦!</h2>
                    <div class="stars">${starText}</div>
                    <p>æœ¬å…³è·å¾— ${starCount} é¢—æ˜Ÿ</p>
                    <div class="buttons">
                        <button class="btn-reset" onclick="restartLevel()">ğŸ”„ é‡ç©</button>
                        <button class="btn-next" onclick="nextLevel()">ä¸‹ä¸€å…³ â†’</button>
                    </div>
                `;
            } else {
                content.innerHTML = `
                    <h2>ğŸ† æ­å–œé€šå…³!</h2>
                    <div class="stars">${starText}</div>
                    <p>æ€»å…±è·å¾— ${totalStars} é¢—æ˜Ÿ</p>
                    <div class="buttons">
                        <button class="btn-reset" onclick="restartGame()">ä»å¤´å¼€å§‹</button>
                    </div>
                `;
            }

            overlay.style.display = 'flex';
        }

        // å¤±è´¥
        function showFail() {
            const overlay = document.getElementById('gameOverOverlay');
            const content = document.getElementById('gameOverContent');

            content.innerHTML = `
                <h2 class="fail-text">ğŸ’¥ ç«è½¦å‡ºè½¨äº†!</h2>
                <p>è·¯å¾„è§„åˆ’æœ‰é—®é¢˜</p>
                <div class="buttons">
                    <button class="btn-reset" onclick="restartLevel()">ğŸ”„ é‡è¯•</button>
                </div>
            `;

            overlay.style.display = 'flex';
        }

        // é‡æ–°å¼€å§‹å½“å‰å…³
        function restartLevel() {
            document.getElementById('gameOverOverlay').style.display = 'none';
            resetLevel();
        }

        // ä¸‹ä¸€å…³
        function nextLevel() {
            document.getElementById('gameOverOverlay').style.display = 'none';
            currentLevel++;
            loadLevel(currentLevel);
            draw();
        }

        // ä»å¤´å¼€å§‹
        function restartGame() {
            document.getElementById('gameOverOverlay').style.display = 'none';
            currentLevel = 0;
            totalStars = 0;
            loadLevel(currentLevel);
            draw();
        }

        // å¯åŠ¨æ¸¸æˆ
        initGame();
    </script>
</body>
</html>
